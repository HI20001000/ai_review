import { collectIssuesForSource } from "./combinedReport.js";
import {
    dedupeIssues,
    isPlainObject,
    normaliseReportSourceKey,
    pickJsonStringCandidate,
    pickReportObjectCandidate,
    remapIssuesToSource,
    stringifyReportCandidate
} from "./shared.js";

/**
 * Retrieve the static analyzer issues from the global state.
 *
 * @param {Record<string, any>} state - Workspace state containing parsed reports and analysis snapshots.
 * @returns {Array<any>} Issues reported by the static analyzer pipeline.
 */
export function collectStaticReportIssues(state) {
    return collectIssuesForSource(state, ["static_analyzer"]);
}

/**
 * Extract the static analyzer report object from a report collection.
 *
 * @param {Record<string, any>} reports - Raw reports keyed by source.
 * @returns {Record<string, any> | null} Static analyzer report or null when not present.
 */
export function extractStaticReport(reports) {
    if (!reports || typeof reports !== "object") {
        return null;
    }
    return reports.static_analyzer || reports.staticAnalyzer || null;
}

/**
 * Merge a static analyzer report into the working analysis structure while tracking Dify enrichment.
 *
 * @param {{ state: Record<string, any>, baseAnalysis: Record<string, any>, reports: Record<string, any>, difyTarget?: Record<string, any> | null }} params
 * @returns {{ difyTarget: Record<string, any> | null | undefined, staticReport: Record<string, any> | null }}
 */
export function mergeStaticReportIntoAnalysis({ state, baseAnalysis, reports, difyTarget }) {
    const staticReport = extractStaticReport(reports);
    if (!staticReport || typeof staticReport !== "object") {
        return { difyTarget, staticReport: null };
    }

    const existingStatic =
        baseAnalysis.staticReport && typeof baseAnalysis.staticReport === "object"
            ? baseAnalysis.staticReport
            : null;
    const mergedStatic = existingStatic ? { ...existingStatic } : {};
    Object.assign(mergedStatic, staticReport);

    if (staticReport.summary && typeof staticReport.summary === "object") {
        mergedStatic.summary = {
            ...(existingStatic?.summary && typeof existingStatic.summary === "object"
                ? existingStatic.summary
                : {}),
            ...staticReport.summary
        };
    } else if (existingStatic?.summary && typeof existingStatic.summary === "object") {
        mergedStatic.summary = { ...existingStatic.summary };
    }

    baseAnalysis.staticReport = mergedStatic;

    const enrichment = staticReport.enrichment;
    let nextDifyTarget = difyTarget;
    if (enrichment !== undefined && enrichment !== null) {
        if (!nextDifyTarget) {
            nextDifyTarget = {};
        }
        if (typeof enrichment === "string" && enrichment.trim()) {
            if (!nextDifyTarget.report || !nextDifyTarget.report.trim()) {
                nextDifyTarget.report = enrichment.trim();
            }
        } else if (enrichment && typeof enrichment === "object") {
            nextDifyTarget.raw = enrichment;
            if (!nextDifyTarget.report || !nextDifyTarget.report.trim()) {
                try {
                    nextDifyTarget.report = JSON.stringify(enrichment);
                } catch (error) {
                    console.warn("[Report] Failed to stringify static enrichment", error);
                }
            }
        }
    }

    const enrichmentStatus =
        typeof baseAnalysis.enrichmentStatus === "string"
            ? baseAnalysis.enrichmentStatus
            : typeof state.analysis?.enrichmentStatus === "string"
            ? state.analysis.enrichmentStatus
            : "";

    const staticSummary =
        baseAnalysis.staticReport?.summary && typeof baseAnalysis.staticReport.summary === "object"
            ? baseAnalysis.staticReport.summary
            : null;

    if (staticSummary) {
        if (enrichmentStatus) {
            const hasStatus =
                typeof staticSummary.status === "string" ||
                typeof staticSummary.status_label === "string" ||
                typeof staticSummary.statusLabel === "string";
            if (!hasStatus) {
                staticSummary.status = enrichmentStatus;
            }
        }
        if (
            !staticSummary.generated_at &&
            !staticSummary.generatedAt &&
            (state.generatedAt || state.analysis?.generatedAt)
        ) {
            staticSummary.generated_at = state.analysis?.generatedAt || state.generatedAt;
        }
    }

    return { difyTarget: nextDifyTarget, staticReport: mergedStatic };
}

/**
 * Prefer issues generated by the static analyzer across different report sources.
 *
 * @param {Record<string, any>} state - Workspace state containing parsed reports and analysis snapshots.
 * @param {Record<string, any>} [reports] - Optional report overrides.
 * @param {string} [sourceKey="static_analyzer"] - Source identifier to normalise against.
 * @returns {Array<any>} Deduplicated static analyzer issues.
 */
export function preferStaticIssues(state, reports, sourceKey = "static_analyzer") {
    const normalisedKey = normaliseReportSourceKey(sourceKey);
    if (!state || !normalisedKey) {
        return [];
    }

    const issues = [];
    const parsedReports = state.parsedReport?.reports;
    const reportEntry = extractStaticReport(parsedReports || reports);

    if (Array.isArray(reportEntry?.issues)) {
        issues.push(...remapIssuesToSource(reportEntry.issues, sourceKey));
    }

    const aggregated =
        reportEntry?.aggregated && typeof reportEntry.aggregated === "object"
            ? reportEntry.aggregated
            : null;
    if (aggregated && Array.isArray(aggregated.issues)) {
        issues.push(...remapIssuesToSource(aggregated.issues, sourceKey));
    }

    const analysisReport =
        state.analysis?.staticReport && typeof state.analysis.staticReport === "object"
            ? state.analysis.staticReport
            : null;
    if (Array.isArray(analysisReport?.issues)) {
        issues.push(...remapIssuesToSource(analysisReport.issues, sourceKey));
    }

    return dedupeIssues(issues);
}

function pickFirstString(...candidates) {
    for (const candidate of candidates) {
        if (typeof candidate !== "string") continue;
        const trimmed = candidate.trim();
        if (!trimmed) continue;
        return trimmed;
    }
    return "";
}

function pickFirstValue(...candidates) {
    for (const candidate of candidates) {
        if (candidate !== undefined && candidate !== null) {
            return candidate;
        }
    }
    return null;
}

/**
 * Build a UI friendly representation of the persisted static analyzer report payload.
 *
 * @param {Record<string, any> | null | undefined} staticReport - Raw static analyzer report payload.
 * @returns {{ summary: Record<string, any> | null, details: Record<string, any> | null }}
 */
export function buildStaticReportDetails(staticReport) {
    if (!isPlainObject(staticReport)) {
        return { summary: null, details: null };
    }

    const summary = isPlainObject(staticReport.summary) ? staticReport.summary : null;
    const aggregated = isPlainObject(staticReport.aggregated) ? staticReport.aggregated : null;
    const metadata = isPlainObject(staticReport.metadata) ? staticReport.metadata : null;
    const enrichment =
        isPlainObject(staticReport.enrichment) || Array.isArray(staticReport.enrichment)
            ? staticReport.enrichment
            : typeof staticReport.enrichment === "string"
            ? staticReport.enrichment.trim()
            : null;

    const issues = Array.isArray(staticReport.issues) ? staticReport.issues : [];
    const aggregatedIssues = Array.isArray(aggregated?.issues) ? aggregated.issues : [];

    const errorMessage = pickFirstString(
        staticReport.error,
        summary?.error,
        summary?.error_message,
        summary?.errorMessage,
        aggregated?.error,
        aggregated?.error_message,
        aggregated?.errorMessage
    );

    const status = pickFirstString(
        staticReport.status,
        summary?.status,
        summary?.status_label,
        summary?.statusLabel,
        aggregated?.status
    );

    const generatedAt = pickFirstValue(
        staticReport.generatedAt,
        staticReport.generated_at,
        summary?.generated_at,
        summary?.generatedAt,
        aggregated?.generated_at,
        aggregated?.generatedAt
    );

    const reportText = pickFirstString(staticReport.reportText, staticReport.report);

    return {
        summary,
        details: {
            summary,
            aggregated,
            metadata,
            issues,
            aggregatedIssues,
            status,
            error: errorMessage,
            generatedAt,
            enrichment,
            reportText
        }
    };
}

/**
 * Build the preferred raw static analyzer JSON payload for preview/export workflows.
 *
 * @param {Record<string, any> | null | undefined} state - Workspace report state snapshot.
 * @returns {string} Stringified static analyzer payload or empty string when unavailable.
 */
export function buildStaticRawSourceText(state) {
    if (!state || typeof state !== "object") {
        return "";
    }

    const parsedReport = isPlainObject(state.parsedReport) ? state.parsedReport : null;
    const reports = parsedReport && isPlainObject(parsedReport.reports) ? parsedReport.reports : null;
    const staticSource = pickReportObjectCandidate(
        reports?.static_analyzer,
        reports?.staticAnalyzer,
        state.analysis?.staticReport
    );
    if (staticSource) {
        const stringified = stringifyReportCandidate(staticSource, "static analyzer report");
        if (stringified) {
            return stringified;
        }
    }

    const fallbackText = pickJsonStringCandidate(
        state.analysis?.rawReport,
        state.analysis?.originalResult,
        state.rawReport
    );
    if (fallbackText) {
        return fallbackText;
    }

    const issues = collectStaticReportIssues(state);
    try {
        return JSON.stringify({ issues });
    } catch (error) {
        console.warn("[reports] Failed to stringify static issue payload", error);
    }

    return "";
}

export default {
    collectStaticReportIssues,
    extractStaticReport,
    mergeStaticReportIntoAnalysis,
    preferStaticIssues,
    buildStaticReportDetails,
    buildStaticRawSourceText
};
